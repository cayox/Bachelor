\section{Entwicklung}
In diesem Kapitel wird die Umsetzung des in Kapitel~\ref{sec:entwurf} besprochenen
Entwurfs erläutert. Es wird nicht nur auf den Projektaufbau und die Implementierung 
von \gls{Frontend} und \gls{Backend} eingegangen, sondern auch auf den 
Softwarelebenszyklus des Projekts und die Dokumentation der \gls{REST} \gls{API}.

\subsection{Projektaufbau}
Das Projekt wurde als ``Monorepo'', also als allumfassendes Repository, entwickelt.
Dadurch sind alle für TestHub benötigten Dateien am gleichen Ort. Weiterhin muss 
keine Synchronisation der Frontend und Backend Versionen stattfinden, was den
Entwicklungs- und Update-Prozess erleichtert~\cite{PL16}.

Dennoch kann das Projekt in zwei interne Teile aufgeteilt werden:

\begin{description}
    \descitem{Frontend}{itm:frontend}\hfill\\
    Unter das Frontend fallen alle vom Client ausgeführten Dateien. Unter das Frontend
    fallen nicht nur die Dateien im \textit{frontend/src} Ordner, wo sich die 
    Controller Dateien befinden, sondern auch alle Dateien in \textit{static/} (kompiliertes JavaScript/CSS) 
    und \textit{templates/} (HTML Dateien).

    \descitem{Backend}{itm:backend}\hfill\\
    Das Backend beschreibt das serverseitige Program, welches auch die \gls{REST} \gls{API}
    implementiert. Der Quellcode dazu liegt im \textit{backend/} Ordner.
\end{description}

Im \textit{frontend/src/} Ordner lassen sich Quellcode für den Style Sheet und 
die Controller finden. Der finale Style Sheet wird mittels TailwindCSS\footurl{https://tailwindcss.com}
kompiliert, welches den Quellcode der HTML und TypeScript Dateien analysiert und
die darin verwendeten \gls{CSS} Klassen generiert. Die Controller hingegen, wurden alle mit 
TypeScript\footurl{https://www.typescriptlang.org} erstellt, welches, im Gegensatz zu 
JavaScript, Typisierung, Interfaces und vieles mehr ermöglicht. Die TypeScript Dateien 
werden in einen einstellbaren JavaScript Standard, wie zum Beispiel ``es2016''
kompiliert. Alle Kompilate werden im \textit{static/} Ordner unter der gleichen 
Struktur gespeichert.

Das Projekt wurde gänzlich im Dateieditor Visual Studio Code\footurl{https://code.visualstudio.com}
unter Verwendung der Go und der JavaScript und TypeScript Extension entwickelt.

\subsection{Implementierung des Frontends}
In diesem Abschnitt wird anhand eines Beispiels aus dem Projekt, die Umsetzung
asynchroner Anfragen erläutert.

\subsubsection{Asynchrones Laden aktiver Jira-Tickets}
Um das Laden der aktiven Tickets so schnell wie möglich zu gestalten, werden die
Tickets asynchron, also pseudo-parallel geladen. Dies wird zum einen möglich, durch
die intuitiv benutzbare Fetch API\footurl{https://developer.mozilla.org/en-US/docs/Web/API/Fetch\_API/Using\_Fetch}
von JavaScript, welche eine einfache asynchrone Umsetzung von Anfragen ermöglicht.
Zum Anderen, kann die Anzahl der angeforderten Tickets durch sogenannte Pagination
limitiert und eingestellt werden. Pagination ist die Möglichkeit, den Umfang 
der angefragten Ressourcen zu limitieren.

\begin{lstlisting}[caption=TypeScript Funktion zum asynchronen Laden aktiver Tickets (\textit{frontend/src/ts/dashboard.ts}),language=TypeScript]
const issueAmount = 20

function loadClimateChamberWidget(){
    var total = 0
    var request_amount = 0

    api<JiraGroupedCCQueryResult>(
        `/jira/active?grouped=true&startAt=0&maxResults=${issueAmount}`
    ).then(res => {
        // first api request to also get the total amount of issues
        total = res.totalResults
        request_amount = res.startAt + res.maxResults
        storeClimateChamber(res.data)
        
        // multiple async requests to load the data faster
        for (
            let i = issueAmount*2;
            i < res.totalResults;
            i+=issueAmount
        ) {
            api<JiraGroupedCCQueryResult>(
                `/jira/active?grouped=true&startAt=${i}&maxResults=${issueAmount}`
            ).then(res => {
                storeClimateChamber(res.data)
            })
        }
    })  
}
\end{lstlisting}

In der Funktion \textit{loadClimateChamberWidget} wird zuerst eine GET Anfrage an die \gls{API} gesendet.
Das Ergebnis ist ein Objekt, welches dem Interface \textit{JiraGroupedCCQueryResult} entspricht.
Die Anfrage wird an die \gls{URI} \textit{/jira/active} gesendet, wobei noch einige optionale 
Formwerte angegeben werden:

\begin{description}
    \item[grouped]
    Angabe, ob die aktiven Tickets vom Server, so wie in \descref{FA\#01}{itm:fa01}
    gefordert, nach Klimakammer sortiert werden sollen.

    \item[startAt]
    Der Startindex, ab welchem die Tickets in der Antwort enthalten werden sollen. In der ersten 
    Anfrage an den Server (Zeile 8) sollen alle Tickets ab dem ersten empfangen werden.

    \item[maxResults]
    Die Anzahl der Tickets, die maximal empfangen werden soll. In der ersten 
    Anfrage an den Server (Zeile 8) sollen maximal 20 Tickets empfangen werden.
\end{description}

Die Antwort des Servers enthält demnach nicht nur die Tickets, sondern auch Informationen
zum Requests, wie die eben genannten \textit{startAt} und \textit{maxResult} Werte
aber auch die Anzahl der gesamten verfügbaren Tickets.

Wenn eine Antwort empfangen wurde, werden weitere Anfragen dieser Art verschickt, mit inkrementiertem \textit{startAt} Wert.
Durch die asynchrone Eigenschaft der \textit{fetch} Funktion (innerhalb der \textit{api} Funktion),
wird nicht auf die Antwort einer Anfrage gewartet bis man die Nächste startet.
Stattdessen können weitere Anfragen gestartet werden, während auf andere Antworten gewartet wird.
Durch diese Umsetzung lässt sich ein wesentlich schnelleres Laden der Jira-Tickets ermöglichen .

\subsection{Implementierung des Backends}
In diesem Abschnitt werden ausgewählte Teile des Backendquellcodes vorgestellt.
Dabei wird nicht nur auf die Umsetzung der Kategorisierung anhand eines Beispiels eingegangen,
sondern auch auf die Kommunikation mit dem \gls{Jira} Server.

\subsubsection{Kategorisieren der Jira Labels}
Das Kategorisieren der Labels wird durch reguläre Ausdrücke (englisch: Regular 
Expressions; kurz: RegEx) umgesetzt. Mit diesen kann der strukturelle Aufbau 
von Text schnell analysiert werden~\cite{fitzgerald2012einstieg}. Da reguläre
Ausdrücke sehr schnell sehr unübersichtlich werden können, wurde zu jedem 
RegEx String ein entsprechender Link zu Regex101.com erstellt, in welchem der String
analysiert, erklärt und getestet werden kann.\\

Im Folgenden wird beispielhaft ein RegEx String für ein Erdungskabel kurz gezeigt 
und aufgeschlüsselt erklärt:

\begin{center}
    \verb@(?i)^gc(_|-)?\d+$@
\end{center}

Die ID eines Erdungskabel hat das Format: GC\_100. Jedoch gibt es, durch das manuelle
Eintragen der ID, häufig andere Variationen dieser ID, welche vom Programm 
dennoch als Erdungskabel kategorisiert werden sollen. Beispiele dieser Variation wären: GC100, gc\_100, GC-100, GC\_0100.
Durch den RegEx String können all diese Formate schnell und ohne viel Quellcode 
erkannt werden. Obwohl der String anfangs recht kompliziert aussieht, lässt er 
sich sehr leicht erklären\footurl{https://pkg.go.de/regexp/syntax}:

\begin{table}[H]
    \centering
    \begin{tabular}{| p{0.2\linewidth} | p{0.5\linewidth} | p{0.2\linewidth} |} 
        \hline
        \textbf{Substring} & \textbf{Erklärung} & \textbf{Beispiel}\\ [0.5ex] 
        \hline
        \verb@(?i)@ & Case-insensitive flag; ignoriert Groß- und Kleinschreibung & - \\ [0.5ex]
        \hline
        \verb@^@ & String muss mit folgendem Zeichensatz beginnen & - \\ [0.5ex] 
        \hline
        \verb@gc@ & akzeptiert nur die Buchstaben ``g'' und ``c'' in dieser Reihenfolge & \textbf{\textcolor{blue}{GC}}\_100 \\ [0.5ex] 
        \hline
        \verb@(_|-)@ & akzeptiert entweder ``\_'' oder ``-'' & GC\textbf{\textcolor{blue}{\_}}100 \\ [0.5ex] 
        \hline
        \verb@?@ & das vorherige Zeichen oder Gruppe darf maximal 1 mal vorkommen & - \\ [0.5ex] 
        \hline
        \verb@\d+@ & akzeptiert nur Zahlen (mindestens eine durch \textbf{+}) & GC\_\textbf{\textcolor{blue}{100}}\\ [0.5ex] 
        \hline
        \verb@$@ & String muss mit vorherigem Zeichensatz enden & - \\ [0.5ex] 
        \hline
    \end{tabular}
    \caption{Aufschlüsselung des regulären Ausdrucks zum Identifizieren einer Erdungskabelstruktur in einem String}
\end{table}

Wenn also die \textit{ParseLabels} Methode eines Jira-Tickets aufgerufen wird, werden
alle Labels nacheinander auf das Passen der Struktur mit einem der definierten ReGex Strings geprüft.
Falls ein Label zu einer gewissen Struktur passt, wird es in das entsprechende \textit{ParsedLabel}
geschrieben. Durch das Kompilieren der ReGex Strings beim Start des Servers, können 
diese so schnell wie möglich die Labels kategorisieren.

\subsubsection{\gls{Jira} Kommunikation}
Das TestHub Backend kommuniziert mit dem \gls{Jira} Server via \gls{HTTP}. Dabei muss 
jede Anfrage eine Authentifizierung im Header mitschicken. Diese Authentifizierung
wird durch den Benutzernamen und das Passwort als Base64 kodierter String ermöglicht.
Diese Methode ist zwar nicht sehr sicher, gerade über eine unverschlüsselte
Verbindung wie \gls{HTTP}, allerdings gibt es, da es keine OAuth Authentifizierung auf
dem \gls{Jira} Server von \gls{JSS} bereitgestellt wird, keine andere Möglichkeit.
Allerdings ist der \gls{Jira} Server nur im Firmennetzwerk erreichbar, was das Sicherheitsrisiko
durch Dritte, die eventuell sensible Daten, wie das Passwort, mitlesen, verringert.

Um die in \descref{NA\#13}{itm:fa13} geforderte Funktionalität umzusetzen, 
wird ein standard Jira-Account verwendet, der die Rechte zu den benötigten Projekten besitzt.
Die Zugangsdaten werden aus Sicherheitsgründen nicht direkt in den Quellcode geschrieben, 
sondern über Umgebungsvariablen gelöst. Solch eine Umgebungsvariable ist eine Variable, 
welche Werte zur Laufzeit eines Programms bereitstellen kann. Sie wird meistens vom Betriebssystem verwaltet.
Durch diese Lösung, existieren die Accountdaten nur auf dem Rechner, wo sie auch
angelegt wurden und können nicht einfach so und geteilt oder von Außen eingesehen werden.
Da es jedoch, je nach Betriebssystem, etwas mühselig ist, Umgebungsvariablen zu
verwalten, verwendet TestHub eine \textit{.env} Datei, welche zur Laufzeit eingelesen
wird und die darin enthaltenen Variablen als Umgebungsvariablen setzt. Diese Datei
wird demnach auch nie in das Versionskontrollsystem aufgenommen und kann trotzdem
leicht unter Entwicklern geteilt werden.

\paragraph{Asynchrone Kommunikation}\hfill\\
Das Kreieren einer asynchronen Funktion in Go ist prinzipiell sehr leicht umsetzbar.
Dazu muss lediglich das \textit{go} Keyword vor eine Funktion geschrieben werden.
Dadurch wird die Funktion in einer Go Routine ausgeführt, welche mit einem Thread 
des Betriebssystems vergleichbar ist. 
Jedoch ist das Problem bei der Entwicklung, dass der Server, wie in Abbildung~\ref{fig:components}
dargestellt, zwischen Client und Server liegt. Daher muss, nachdem der Client 
eine entsprechende Anfrage geschickt hat, der TestHub Server die Daten vom \gls{Jira} 
Server so schnell wie möglich lesen und in der gewünschten Form an den Client zurücksenden.
Werden die Anfragen von TestHub an \gls{Jira} jedoch in einer Go Routine ausgeführt, wird logischer Weise nicht
auf die Antwort des \gls{Jira} Servers gewartet, bis die nächste Zeile Code ausgeführt wird.
Dadurch würde TestHub dem Client mit einem leeren Datensatz antworten.

Aus diesem Grund müssen diese Anfragen weiterhin asynchron verschickt werden, um den Geschwindigkeitsbonus
beizubehalten, jedoch muss auf jede Jira-Antwort gewartet werden, bis TestHub an
den Client eine Rückmeldung geben kann.

Die Implementierung dieses Lösungsansatzes wird an einem Auszug der in \descref{NFA\#30}{itm:nfa30}
geforderten Projektübersicht erklärt.


\begin{lstlisting}[caption=Go Umsetzung von asynchronen HTTP Anfragen (\textit{backend/api/api\_jira.go}), language=Go, label={asyncgo}]
    // create a channel to retrieve the results of each request
    c := make(chan *models.JiraAsyncQueryResult)
    // create a waitgroup to wait for all requests to finish
    var wg sync.WaitGroup

    // asynchronously query jira server
    for key := range projects {
        wg.Add(1)
        jql := fmt.Sprintf(config.JQL_TICKETS_PER_PROJECT, key)

        go jira.QueryIssuesAsync(key, c, &wg, jql, []string{}, 0, 1)
    }

    go func() {
        // this blocks the goroutine until WaitGroup counter is zero
        wg.Wait() 
        close(c)  // Channels need to be closed
    }()

    totalResults := 0
    // parse all received data
    for res := range c {
        // do something with results
    }
    // respond to client
\end{lstlisting}

Im Codebeispiel~\ref{asyncgo} ist das rapide starten mehrerer HTTP Anfragen zu sehen. Um dies in
Go zu ermöglichen, wird eine \textit{WaitGroup} benötigt, welche eine \gls{threadsicher}e
Möglichkeit bietet, das Ausführen weiteren Codes zu verhindern, solange mindestens
ein Element in der \textit{WaitGroup} noch nicht beendet wurde. Man kann sich diese
\textit{WaitGroup} wie einen Zähler vorstellen, welcher zählt, wie viele Funktionen
gestartet und wie viele beendet wurden.

Um eine Kommunikation mit den Go Routinen herzustellen, wird ein von Go 
bereitgestellter \gls{threadsicher}er Channel verwendet. 
Dieser kann Daten in Form der \textit{JiraAsyncQueryResult} Struktur speichern. 

Ab Zeile 7 wird pro Projekt die \textit{WaitGroup} hochgezählt und ein \gls{JQL}
String erstellt. Anschließend wird die \textit{QueryIssuesAsync} Funktion in einer
Go Routine ausgeführt, welche die tatsächliche Anfragelogik beinhaltet. Diese Funktion
erhält, neben den Standardparametern einer Jira Anfrage auch den Key, zur Identifikation der Antwort,
den Channel, zum versenden der Antwort an die Haupt-Go-Routine und eine Referenz 
der \textit{WaitGroup} zum Dekrementieren dieser, nach der Termination der Funktion.

Darauf folgend wird in Zeile 16 auf das Beendigen aller zuvor gestarteten Go 
Routinen gewartet. Anschließend wird der Channel wieder geschlossen, damit aus diesem
die gespeicherten Daten entnommen und weiterverarbeitet werden können.

\subsubsection{REST API Dokumentation}
Um die Anforderung \descref{NFA\#20}{itm:nfa20} zu erfüllen, wurde eine Dokumentation
mittels Postman\footurl{https://www.postman.com} erstellt. Postman ist ein Programm
zum gemeinsamen Testen und Debuggen von APIs. Es bietet zusätzlich an eine Dokumentation
zu generieren und bereitzustellen. Diese Dokumentation lässt sich mit Beispielen von 
den tatsächlichen Anfragen und realen Antworten vom Server versehen.
Dadurch lässt sich das Testen der API Endpunkte und das Dokumentieren
dieser effizient zusammenfassen und an einem Ort wiederfinden. Außerdem kann in der
Dokumentation automatisch die gewünschte Sprache und somit Codebeispiele für die
jeweiligen Anfragen generiert werden. Durch die zusätzliche Integration von Markdown, 
lassen sich aussagekräftige und tatsächlich hilfreiche API Dokumentationen erstellen.


\subsection{Bereitstellung}
Das Deployment des Systems kann ziemlich einfach erfolgen, da es nur firmenintern
zur Verfügung stehen muss. Dafür gibt es innerhalb der \gls{HOD} Abteilung einen
dafür bestimmten Windows-Rechner. Dieser Rechner fungiert als Server, auf dem TestHub
laufen kann. Da die Auslastung von TestHub ziemlich gering ausfallen wird, da es 
eine sehr spezifische Anwendung ist, wird auch kein Reverse Proxy oder Loadbalancing
benötigt. Dadurch das TestHub eigene Datenbank Cluster verwendet, können diese auch problemlos in 
die schon vorhandene MongoDB Instanz integriert werden. Mittels der Portweiterleitung
fast aller freien Ports innerhalb der Firma, lässt sich Testhub
ohne großen Aufwand bereitstellen.

\newpage