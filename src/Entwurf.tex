\section{Entwurf}\label{sec:entwurf}
Im folgenden Kapitel soll der Prozess der Gestaltung des \gls{UI}s erläutert 
werden. Des Weiteren wird die Architektur des \gls{Backend}s und einiger Komponenten
genauer beschrieben.

\subsection{Entwurf des GUI}
Im folgenden Abschnitt wird das Grundlegende Design kurz erläutert. AnschließenD
wird auf den Aufbau und Entwurf der zwei Haupt-Webseiten von ``TestHub'' eingegangen. 

Da ``TestHub'' im Browser auf verschiedenen Bildschirmen laufen wird, muss das 
Design auch eine gewisse ``Responsiveness'' haben, was bedeutet, dass sich die 
GUI dem Viewport anpasst.

\subsubsection{Grunddesign}\label{sec:grunddesign}
Um das in \descref{NFA\#21}{itm:nfa21} angesprochene einheitliche Design umzusetzen, 
wurde ein simples Design erstellt, welches sich im gesamten Projekt wiederfinden
lässt. Das Design basiert auf ``Karten'' welche sich leicht entwerfen lassen und
zudem übersichtlich und skalierbar sind.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{img/KartenDesign.png}
    \caption{Finales Kartendesign}\label{fig:card}
\end{figure}

Das Kartendesign wurde mit dem Designtool Figma\footurl{https://www.figma.com} erstellt. Jede Karte besitzt 
einen Header welcher die Hintergrundfarbe \textit{\#1f2937} besitzt. In diesem
Header lassen sich der Karten Titel und ein Button wiederfinden.
Der Titel der Karte sollte dabei immer eine kurze Beschreibung des Inhalts sein.
Der Button in der rechten Ecke des Headers its optional und kann beliebig 
angepasst werden. Der Body der Karte lässt platz für alle beliebigen Elemente.
Durch das simple Design sind die Höhe und Breite der Karte variabel, wodurch 
jedes beliebige Element im Body platz findet. Um die Benutzererfahrung zu verbessern,
wird beim Hovern über der Karte, diese in einer Animation etwas nach oben verschoben. 
Zusätzlich wird der Schatten der Karte vergrößert, sodass sie einen Anhebe-Effekt
erhält, welcher jedoch nicht zu ablenkend ist.

\subsubsection{Entwurf einer kompakten Jira-Ticket Komponente}\label{sec:jirakompakt}
Da es Sinn macht, vorherige und folgende Tests zusammen mit dem aktiven Test 
anzuzeigen, wurde ein Element entworfen, welches die wichtigsten Informationen 
des Tickets in kompakter Weise anzeigt und trotzdem die Möglichkeit bietet, den 
vorherigen und folgenden Test einzusehen.
Durch die Verwendung von TailwindCSS konnte die Komponente schnell und einfach 
direkt in \gls{HTML} entworfen werden. Dadurch lässt sie sich auch leichter in
das fertige Projekt einbauen.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{img/TicketKompakt.png}
    \caption{Kompakte Jira-Ticket Komponente}\label{fig:ticketcompact}
\end{figure}

In dem Design dieser Komponente lassen sich die wichtigsten Ticket Informationen
auf einen Blick erkennen, wie in~\descref{FA\#02}{itm:fa02} gefordert. 
Falls man dennoch das ganze Jira-Ticket ansehen möchte,
kann dies über die Verlinkung der Ticket-ID (Abb.~\ref{fig:ticketcompact}, Nr. 1) geschehen. Des Weiteren sieht man in 
dieser Komponente auch schnell, falls ein Test der letzte Test ist (Abbildung
~\ref{fig:ticketcompact} Nr. 3). Klickt man auf eine freie Stelle innerhalb
der Komponente, soll sich die Detailansicht des Tickets öffnen, klickt man auf 
den Knopf des vorherigen oder folgenden Tests, soll sich die Detailansicht des 
entsprechenden Tickets öffnen. Weiterhin lässt sich durch die geringe Höhe der 
Komponente eine kompakte Auflistung mehrerer Tickets ermöglichen.

\subsubsection{Dasboard}
Um die in \descref{FA\#05}{itm:fa05} geforderte schnelle Übersicht zu entwerfen, 
wurde zuerst analysiert, welche Daten angezeigt werden müssen. Wie in der 
Anforderung \descref{FA\#05}{itm:fa05} beschrieben müssen sowohl die aktiven Jira-Tickets als auch 
aufkommende Wartungen angezeigt werden. All diese Informationen sollen auf dem 
``Dashboard'' übersichtlich dargestellt werden. Das Dashboard soll gleichzeitig
die Hauptseite des Projekts sein.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{img/DashboardMockUp.png}
    \caption{MockUp des Dashboards}\label{fig:dashboard}
\end{figure}

In Abbildung~\ref{fig:dashboard} ist ein Mockup des Dashboards zu sehen. 
Die Entwicklung des Dashboards folgte einem iterativen Prozess. Das Mockup wurde
den betroffenen Personen vorgestellt und in mehreren Schritten verfeinert, indem die 
Rückmeldungen der Befragten implementiert wurden.\\

Das Dashboard benutzt das in Abschnitt~\ref{sec:grunddesign} gezeigte Kartendesign.
Dabei wird das Dashboard in drei Spalten aufgeteilt, welche die aktiven Tests nach
Klimakammer gruppiert (Abb.~\ref{fig:dashboard}, Nummer 1), 
die aufkommenden Wartungen (Abb.~\ref{fig:dashboard}, Nummer 2) und eine 
Projektübersicht (Abb.~\ref{fig:dashboard}, Nummer 3) bietet. In den Klimakammerkarten
lässt sich auch die in Abschnitt~\ref{sec:jirakompakt} gezeigte kompakte Jira-Ticket 
Komponente wiederfinden. \\

Da es für die Jira-Tickets viele weitere interessante Informationen gibt, welche
jedoch sich nicht in einer kompakten Ansicht anzeigen lassen, gibt es für jedes
aktive, vorherige und folgende Ticket eine Detailansicht. Damit wird sowohl die
funktionale Anforderung \descref{FA\#02}{itm:fa02} als auch \descref{FA\#03}{itm:fa03} erfüllt.
Die Detailansicht wird durch ein Modal umgesetzt. Ein Modal ist ein Dialog, welcher den Rest der Anwendung sperrt,
bis das Modal wieder geschlossen wird.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{img/TicketModal.png}
    \caption{MockUp des Modals zur anzeige von Jira-Ticket Details}\label{fig:modal}
\end{figure}

In Abbildung~\ref{fig:modal} werden nur einige der Labelkategorien angezeigt.
Falls es nicht möglich ist, ein Label zu kategorisieren, wird dieses ganz unten 
unter ``Unknown Labels'' angezeigt. 

\subsubsection{Ressourcendetailansicht}
Um die Details einer Ressource einzusehen und diese zu bearbeiten muss es eine 
extra dafür angefertigte Seite geben. 

\begin{figure}[H]
    \includegraphics[width=\linewidth]{img/RessourceMockUp.png}
    \caption{MockUp der Ansicht einer spezifischen Ressource}\label{fig:ressource}
\end{figure}

Auch in dieser Ansicht lässt sich das Design aus Abschnitt~\ref{sec:grunddesign}
wiederfinden. Das~\nameref{fig:ressource} liefert alle wichtigen Informationen
auf einen Blick. Viele dieser Informationen lassen sich auch interaktiv anpassen
und mit dem ``Save'' Button übernehmen. Die Kategorien und Tags zeigen bei Benutzung
des jeweiligen Eingabefeldes, die schon vorhandenen Kategorien oder Tags des Servers
an, um die Eingabe so bequem wie möglich zu machen. \\

Unter der Equipment Karte, befinden sich noch zwei weitere Karten. Die linke Karte
zeigt dabei die in \descref{FA\#22}{itm:fa22} geforderten Tickets, welche die 
entsprechende Ressource verwenden. In Abbildung~\ref{fig:ressource} unter Nr. 7 sieht man die Ansicht,
wie sie aussieht, wenn es keine solcher Tickets gibt. Falls es diese doch Tickets gibt, 
wird die Klimakammeransicht aus Abbildung~\ref{fig:dashboard} Nr. 1 erneut verwendet,
um die Tickets anzuzeigen.

Mit dem ``Update'' Button kann ein neuer Wartungstermin erstellt werden.
Es öffnet sich erneut ein Modal wo die in \descref{FA\#11}{itm:fa11}, 
\descref{FA\#30}{itm:fa30} und \descref{FA\#31}{itm:fa31} geforderten wartungsspezifischen
Informationen eingetragen und abgespeichert werden können. Dadurch wird ein neuer
Wartungstermin festgelegt und ein Wartungsverlaufeintrag erstellt.


\subsection{Entwurf der Softwarearchitektur}\label{sec:swArchitectur}
Im Kapitel~\ref{sec:swArchitectur} wird die Architektur der Software detailliert 
erläutert. Zusätzlich werden alle Systemkomponenten erklärt und auf die 
Datenmodellierung eines Jira-Tickets erläutert. Zum Schluss wird auf die Struktur
der \gls{UI}-Komponenten eingegangen.

\subsubsection{Systemarchitektur}
Das System ist in dem klassischen Server-Client-Prinzip aufgebaut, in dem der Server, 
als \gls{Backend}, die nötigen Daten zur Verfügung stellt und der Client diese 
abfragen kann um seine spezifischen Aufgaben zu lösen~\cite{Nie13}.
In diesem Fall ist der Client der Webbrowser mit dem der Benutzer interagiert. 
Die Server-Komponente, stellt die Daten aus der Datenbank oder dem \gls{Jira} Server
zur Verfügung. Der Server dient auch als Webserver, indem er ebenfalls die
\gls{HTML}, \gls{CSS} und Javascript Dokumente zur Verfügung stellt.\\

\begin{figure}[H]
    \includegraphics[width=\linewidth]{diagramme/KomponentenDiagramm.png}
    \caption{UML-Komponentendiagramm zur Systemarchitektur}\label{fig:components}
\end{figure}

In Abbildung~\ref{fig:components} sind die genannten Komponenten visuell dargestellt.
Die dick geschriebenen Komponenten sind in dieser Arbeit entwickelt worden, alle
anderen werden nur als Quellen genutzt, um Daten zu erhalten oder Interaktionen zu 
ermöglichen. Dadurch ergeben sich 3 Hauptkomponenten:

\begin{description}
    \descitem{GUI}{itm:GUI}\hfill\\
    Die Grafische Benutzeroberfläche mit der der Benutzer interagieren kann.
    Die \gls{GUI} wird durch strukturell durch \gls{HTML} Dokumente ermöglicht. 
    Das Design wird dabei durch TailwindCSS\footurl{https://tailwindcss.com} umgesetzt.

    \descitem{Server}{itm:server}\hfill\\
    Der Server bietet über eine \gls{REST} \gls{API} (siehe Abs.~\ref{sec:restapi})
    die vom Client benötigten Daten an. Der Server kann dabei eine Vielzahl an Clients
    gleichzeitig bearbeiten.

    \descitem{Controller}{itm:controller}\hfill\\
    Der Controller verarbeitet die Daten des Servers, sodass sie in der GUI
    dargestellt werden können. Er ist ein eigenes JavaScript Programm,
    welches vom Browser ausgeführt wird.\\
\end{description}

Zusätzlich gibt es zwei weitere Komponenten mit denen der Server interagiert:

\begin{description}
    \descitem{Jira Server}{itm:jiraserver}\hfill\\
    Der \gls{Jira} Server ist der Server auf dem das Programm \gls{Jira} ausgeführt wird, 
    welches die Informationen zu allen Tests beinhaltet.

    \descitem{Datenbank}{itm:datenbank}\hfill\\
    Die Datenbank dient als zweite Informationsquelle. In ihr speichert der Server
    die Daten der Ressourcen, welche üblicher Weise nicht durch \gls{Jira} verwaltet
    werden.
\end{description}

Die Kommunikation der Komponenten erfolgt auf unterschiedliche Weisen. Während 
der Controller mit der GUI über das vom Browser zur Verfügung gestellte \gls{DOM}
Interface interagiert, kommuniziert er mit dem Server via \gls{HTTP} (siehe \nameref{sec:HTTP}).
Der Server fragt seine Daten ebenfalls über HTTP vom \gls{Jira} Server an. Um Einträge
in der Datenbank zu speichern, anzupassen oder abzufragen wird die Query-Sprache
der Datenbank verwendet.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{diagramme/SequenzDiagramm.png}
    \caption{UML-Sequenzdiagramm zur Anfrage der aktiven Tickets bei Initialisierung}\label{fig:sequenz}
\end{figure}

In Abbildung~\ref{fig:sequenz} ist die Kommunikation beim Laden der aktiven Tickets des Dashboards 
dargestellt. Da sich der Ablauf immer ähnelt, nur der rechte Teilnehmer, je nach 
Anfrage die Datenbank ist, kann man dieses Prinzip auf die Kommunikation des gesamten
Systems beziehen. Der Server ist demnach nur eine Zwischenkomponente, welche die
Daten einheitlich, gesammelt und aufbereitet wiedergibt.

Aus Übersichtlichkeitsgründen wurde die \descrefnobold{GUI}{itm:GUI}
und der \descrefnobold{Controller}{itm:controller} als Client zusammengefasst.\\

\subsubsection{\gls{Jira} Ticket Modellierung}
Ein JiraTicket ist im Backend wie in Abbildung~\ref{fig:classes} strukturiert. Die Struktur ist abgeleitet 
von dem \gls{JSON}-Dokument, welches der \gls{Jira} Server versendet. Der \gls{Jira} Server
sendet noch viele weitere Informationen zu einem Ticket, welche aufgrund der Relevanz
nicht beachtet werden.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{diagramme/KlassenDiagramm.png}
    \caption{UML-Klassendiagramm zur Jira-Ticket Struktur}\label{fig:classes}
\end{figure}

In Abbildung~\ref{fig:classes} ist zu sehen, dass ein JiraIssue hauptsächlich aus 
seinen ``Field''-Attributen besteht. Diese decken sich größtenteils mit der 
\gls{JSON} Repräsentation des \gls{Jira} Tickets. Sie wurde lediglich um die ParsedLabels Struktur 
erweitert, um die Labels in aufgeschlüsselter Form anzuzeigen (siehe \descref{FA\#03}{itm:fa03}). Dafür wird auch die
öffentliche Methode \textit{ParseLabels} eingeführt, welche das Parsen, also das
Analysieren und Kategorisieren durchführt. 

In den ``Field''-Attributen lassen sich auch die Verlinkungen wiederfinden, falls 
es welche gibt. Diese Verlinkungen werden durch eine eigene Struktur realisiert.
Dabei erhält jeder Link eine ID, die Art der Verlinkung und einen Inward- \textit{oder}
einen Outward-Issue. ``Inward'' bedeutet in diesem Fall, dass ein anderes Ticket auf dieses
Ticket verlinkt, ``Outward'' beschreibt hingegen die ausgehende Verlinkung vom Ticket aus. 
Um riesige Baumstrukturen durch die Verlinkungen zu vermeiden, 
ist zwar der Inward- bzw. Outward-Issue ein Objekt der JiraIssue Klasse, jedoch 
werden in dem verlinken Ticket nur eine geringe Anzahl der Felder mit Werten befüllt.
Des Weiteren hat das verlinkte Ticket nie weitere Verlinkungen.

Die jeweilige Art der Verlinkung wird in der separaten 
``JiraIssueLinkType'' Struktur festgehalten. Dort findet man auch die Beschreibung
der Beziehung zwischen den Tickets in Worten. Durch diese Verlinkungsstruktur
lassen sich die vorherigen und folgenden Tests, wie in \descref{FA\#04}{itm:fa04}
gefordert, ermitteln.

Nicht nur für die Verlinkung gibt es extra Strukturen, auch der Status, das Projekt, 
die Testklasse und Accounts werden in eigenen Strukturen betrachtet, um weitere
Informationen zu dem jeweiligen Feld zu liefern.

Das Parsen zu oder von der \gls{JSON} Repräsentation kann in GO sehr leicht über
sogenannte ``Tags'' realisiert werden. Somit kann bei der Deklaration der Struktur
direkt der \gls{JSON}-Key mit angeben werden, welcher zur (De)Serialisierung verwendet wird.

\begin{lstlisting}[caption=Go Strukturdefinition mit JSON Tags,language=Go]
type JiraIssue struct {
    ID     string     `json:"id"`
    Key    string     `json:"key"`
    Fields JiraFields `json:"fields"`
}
\end{lstlisting}

Ein in \gls{JSON} serialisiertes Jira-Ticket, beispielsweise im Body einer Antwort
des Servers, sieht wie folgt aus:

\begin{lstlisting}[caption=gekürzte beispielhafte JSON Repräsentation eines Jira-Tickets,language=json,label={lst:jirajson}]
{
    "id": "12345",
    "key": "C3000000-1234",
    "fields": {
        "labels": [
            "Au123",
            "HW:123",
            "RBS:1.2.3",
            "SW:321",
            "heated"
        ],
        "parsed_labels": {
            "arduino_sw": "Au123",
            "ecu_hw": "HW:123",
            "ecu_sw": "SW:321",
            "heated": true,
            "restbus_sim": "RBS:1.2.3",
            "last_test": false,
            "unknown_labels": null,
            // ...
        },
        "description": "Please perform TCSY000",
        "created": "2022-03-09T08:27:41.000+0100",
        "updated": "2022-03-23T13:34:59.000+0100",
        "assignee": {
            "name": "paellern",
            "key": "paellern",
            "displayName": "Nico Paeller",
            "emailAddress": "nico.paeller@joysonsafety.com",
            "avatarUrls": {
                // ...
            }
        },
        "status": {
            "id": "10900",
            "name": "Ready for Test",
        },
    }
}
\end{lstlisting}

Diese \gls{JSON}-Repräsentation eines Jira-Tickets wurde gekürzt, um die Übersichtlichkeit
dieses Dokuments zu erhalten. \\

In Codebeispiel~\ref{lst:jirajson} können auch die Labels im Vergleich zu den
``ParsedLabels'' gesehen werden.

\subsubsection{Komponentenarchitektur}
Die einzelnen Komponenten wurden nach der \gls{MVC}-Architektur entworfen. Unter
Komponenten sind hier die Views, also die einzelnen Webseiten (Dashboard, etc.) 
von TestHub gemeint.

\begin{figure}[H]
    \includegraphics[width=\linewidth]{diagramme/MVC.png}
    \caption{UML-Klassendiagramm zur Jira-Ticket Struktur}\label{fig:classes}
\end{figure}

Das Projekt ist also in drei Teile unterteilt:
\begin{description}
    \descitem{Model}{itm:model}\hfill\\
    Das Model beinhaltet die Informationen, welche dargestellt werden sollen. Das
    Model ist im Fall von ``TestHub'' der Server, welcher die Daten zur Verfügung stellt.

    \descitem{View}{itm:view}\hfill\\
    Das View übernimmt die Anzeige der Daten an den Benutzer. Es kann zusätzlich
    verschiedene Methoden zur Verfügung stellen, um Benutzereingaben an den Controller
    weiter zu geben. Bei TestHub ist das View das Zusammenspiel aus \gls{HTML} und \gls{CSS}.

    \descitem{Controller}{itm:mvcController}\hfill\\
    Der Controller stellt die Schnittstelle zwischen View und Model her. Er kann 
    auf Eingaben vom View reagieren und entsprechende Models laden und anzeigen lassen.
    Der Controller wird durch die JavaScript/TypeScript Programme umgesetzt.
\end{description}

Durch diese Architektur bleibt das Projekt übersichtlich gegliedert und erweiterbar, 
da einzelne Views, Controller oder Models ausgetauscht werden und somit eine andere 
Darstellung oder Funktionalität bieten können~\cite{Aug20}. Des Weiteren ist das Projekt so 
aufgebaut, dass der einzige Punkt, wo View und Controller zusammengeführt werden,
das Laden des jeweiligen Skripts im \gls{HTML} Head ist. Da es keine weiteren 
Funktionsaufrufe oder Ähnliches im \gls{HTML} Dokument gibt, kann der Controller
aufgebaut und Design werden, wie es nötig ist. \\

Die schemenhafte Umsetzung dieser Architektur lässt sich in Abbildung~\ref{fig:components}
wiederfinden.

\newpage